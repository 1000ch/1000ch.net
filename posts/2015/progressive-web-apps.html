<!doctype html><html lang=ja>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Progressive Web Appsとは - EagleLand</title>
<link rel=icon href=/favicon.png>
<link rel="shortcut icon" href=/favicon.png>
<link rel="shortcut icon" href=/favicon.svg type=image/svg+xml sizes=any>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/dracula.min.css>
<link rel=stylesheet href=/css/settings.css>
<link rel=stylesheet href=/css/tools.css>
<link rel=stylesheet href=/css/generic.css>
<link rel=stylesheet href=/css/base.css>
<link rel=stylesheet href=/css/objects.css>
<link rel=stylesheet href=/css/components.css>
<link rel=stylesheet href=/css/trumps.css>
<link rel=alternate href=/rss.xml title=1000ch.net type=application/rss+xml>
<meta name=author content="Shogo Sensui">
<meta name=copyright content="Copyright (c) Shogo Sensui; Licensed under Creative Commons Attribution-Noncommercial-Share Japan">
<meta property="og:description" content="Progressive Web Appsとは 今年の Chrome Dev Summit でもセッションにあった Progressive Web Apps について。Progressive Web Apps は特定の技術を指す言葉ではなく、 Web の進化していくべき姿 を提唱しているものだ。Alex Russell 氏が自身のブログで綴ったのが事の始まりで、Chrome Dev Summit でも初日は Progressive Web Apps をテーマにセッションが組まれた。
 Web アプリとネイティブアプリ 昨今、パソコンで Web を閲覧する時にパフォーマンスがボトルネックになることは少なくなってきている。パソコンの性能はネットワークインフラに比べれば進化が順調であり、ネットワークも光回線のように十分に速度が得られる環境でインターネットをすることが大半ではないだろうか。
しかしモバイルデバイスではどうだろうか。iPhone や Android 端末の性能も良くなってきているとはいえ、MacBook Pro とは比較にならないし、4G の提供エリアであっても建物の中や地下鉄に乗っていれば相応の影響を受けるといったように、ネットワークも不安定であることが多い（それでも着実に整備が進んでいると思うが）。
要するに、閲覧環境が不安定なのだ。HTML・CSS・JavaScript・画像・動画といったようなリソースをネットワークを介して適時取得する必要がある Web にとっては、サービスの価値を左右する要因になってしまう。低スペックの端末だろうと、貧弱なネットワーク環境であろうと、ユーザーはスムースに閲覧できることをいつも期待しているからだ。
それに比べてネイティブアプリは、リソースの大半がアプリにバンドルされているため、起動後はネットワークからリソースを読み出す回数が Web に比べて少ない。オフライン時にもキャッシュデータをロードするなど、オフラインになったことを意識させない設計になっていることが多く、Web のように画面が真っ白になってしまうことが少ない。動作も OS ネイティブのランタイムで動作するため、ブラウザエンジンというレイヤを介す Web はどうしてもパフォーマンスが出難い。
加えて、Web ではサービスの要件を機能面で満たせないことが多かった。カメラ、ジャイロスコープ、最近だと iOS の 3D Touch など。プッシュ通知もその中のひとつである。
A year ago, I asked what features made you turn to native. #1 response: push notifications.">
<meta property="og:image" content="https://1000ch.net/img/apple-touch-icon.png">
<meta name=twitter:card content="summary">
<meta property="og:type" content="article">
<meta property="og:url" content="https://1000ch.net/posts/2015/progressive-web-apps.html">
<meta property="og:site_name" content="EagleLand">
<meta property="og:title" content="Progressive Web Appsとは">
<meta name=twitter:site content="@1000ch">
<meta name=twitter:url content="https://1000ch.net/posts/2015/progressive-web-apps.html">
<meta name=twitter:title content="Progressive Web Appsとは">
<meta name=google-site-verification content="BWewniqiBzRmrhpj51eLwug-F4hamFfyznl-ARb-Y4Y">
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon.png>
<link rel=apple-touch-icon-precomposed sizes=114x114 href=/img/apple-touch-icon.png>
<link rel=apple-touch-icon-precomposed sizes=72x72 href=/img/apple-touch-icon.png>
<link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png>
<script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-49530352-1','1000ch.net'),ga('send','pageview')</script>
</head>
<body>
<div class=Container>
<header class=Header>
<h1 class=Header__Title>
<a href=/>EagleLand</a>
</h1>
<nav class=Header__Menu>
<div class=Header__MenuItem>
<a href=/rss.xml>📻 RSS</a>
</div>
<div class=Header__MenuItem>
<a href="https://www.google.co.jp/search?q=site%3A1000ch.net">🔍 検索</a>
</div>
<div class=Header__MenuItem>
<a href=https://shogosensui.com>🌎 Who is 1000ch</a>
</div>
</nav>
<div class=Preference>
<label>
<input type=checkbox switch id=auto-phrase> 日本語のフレーズ改行
</label>
<label>
<input type=checkbox switch id=dark-mode> ダークモード
</label>
</div>
</header>
<main class=Main>
<span class="Label Label--gray pull-left">2015.12.24</span>
<h1 id=progressive-web-appsとは>Progressive Web Appsとは</h1>
<p>今年の Chrome Dev Summit でもセッションにあった <a href="https://www.youtube.com/watch?v=MyQ8mtR9WxI">Progressive Web Apps</a> について。Progressive Web Apps は特定の技術を指す言葉ではなく、 <strong>Web の進化していくべき姿</strong> を提唱しているものだ。<a href=https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/>Alex Russell 氏が自身のブログで綴った</a>のが事の始まりで、Chrome Dev Summit でも初日は Progressive Web Apps をテーマにセッションが組まれた。</p>
<iframe loading=lazy src=https://www.youtube.com/embed/MyQ8mtR9WxI title="YouTube video player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen style=aspect-ratio:16/9></iframe>
<h2 id=web-アプリとネイティブアプリ>Web アプリとネイティブアプリ</h2>
<p>昨今、パソコンで Web を閲覧する時にパフォーマンスがボトルネックになることは少なくなってきている。パソコンの性能はネットワークインフラに比べれば進化が順調であり、ネットワークも光回線のように十分に速度が得られる環境でインターネットをすることが大半ではないだろうか。</p>
<p>しかしモバイルデバイスではどうだろうか。iPhone や Android 端末の性能も良くなってきているとはいえ、MacBook Pro とは比較にならないし、4G の提供エリアであっても建物の中や地下鉄に乗っていれば相応の影響を受けるといったように、ネットワークも不安定であることが多い（それでも着実に整備が進んでいると思うが）。</p>
<p>要するに、閲覧環境が不安定なのだ。HTML・CSS・JavaScript・画像・動画といったようなリソースをネットワークを介して適時取得する必要がある Web にとっては、サービスの価値を左右する要因になってしまう。低スペックの端末だろうと、貧弱なネットワーク環境であろうと、ユーザーはスムースに閲覧できることをいつも期待しているからだ。</p>
<p>それに比べてネイティブアプリは、リソースの大半がアプリにバンドルされているため、起動後はネットワークからリソースを読み出す回数が Web に比べて少ない。オフライン時にもキャッシュデータをロードするなど、オフラインになったことを意識させない設計になっていることが多く、Web のように画面が真っ白になってしまうことが少ない。動作も OS ネイティブのランタイムで動作するため、ブラウザエンジンというレイヤを介す Web はどうしてもパフォーマンスが出難い。</p>
<p>加えて、Web ではサービスの要件を機能面で満たせないことが多かった。カメラ、ジャイロスコープ、最近だと iOS の 3D Touch など。プッシュ通知もその中のひとつである。</p>
<blockquote class=twitter-tweet lang=ja><p lang=en dir=ltr>A year ago, I asked what features made you turn to native. #1 response: push notifications. Today, they're available: <a href=http://t.co/wDOKa5qVbf>http://t.co/wDOKa5qVbf</a></p>&mdash; Paul Irish (@paul_irish) <a href=https://twitter.com/paul_irish/status/576089864514326528>2015, 3月 12</a></blockquote>
<p>こうした状況を背景に、iOS や Android がアプリのプラットフォームとして選択されてきた。Mark Zuckerberg 氏が HTML5 に水を差したのも少なからず原因の1つだと思うが。</p>
<h2 id=プラットフォームとしての-web-の進化>プラットフォームとしての Web の進化</h2>
<p>ネイティブにはない Web のメリットもたくさんある。ストアから探してインストールせずとも使えるし、見つけ出したら URL で簡単にシェアできる。また、Google Play や App Store といったベンダープラットフォームに縛られないというメリットもある。これは見方によっては、エコシステムの恩恵を享受できない（アプリのカテゴライズ・配布されるアプリの品質担保・ストアからのプロモートなど）とも捉えられるが、大半は Web でも補うことができるだろう。</p>
<p>Web がプラットフォームとしてネイティブアプリ同等の機能を提供できれば良いということは、Web のエヴァンジェリスト達が唱え続けてきたことだ。<a href=https://havelog.aho.mu/develop/performance/e664-rail_performance_model.html>パフォーマンスモデルとして RAIL</a> が唱えられたり、<a href=/posts/2014/service-worker-internals.html>Service Worker</a> も Web の機能性を大きく前進させるために生まれた。これらで実現されることを標榜したのが Progressive Web Apps であると理解している。マーケティング色も強いが、認知拡大も技術推進のために必要なことだろう。</p>
<h2 id=progressive-web-apps-を表す特徴>Progressive Web Apps を表す特徴</h2>
<p>では具体的にどういったことを提供すればいいかという話になるが、Alex Russell 氏は先に紹介したブログの記事で以下のように挙げている。しかし、これらを全て満たす必要があるとかではなく、Web としてより良い特徴が羅列されているとも捉えられる。</p>
<ul>
<li><strong>レスポンシブである</strong>: どんな閲覧環境にも最適化されたレイアウトで表示されること</li>
<li><strong>オンラインでもオフラインでも動作する</strong>: オフライン時でもオンライン時に近い振る舞いをすること。<a href=/posts/2015/service-worker-passive-cache.html>Service Worker による通信のハンドルと Cache API によるリソースの制御</a>でオフライン化を実現できる</li>
<li><strong>ネイティブアプリのようなインタラクション</strong></li>
<li><strong>最新に更新されている</strong>: Service Worker の Background Sync 等で、常に最新が提供できること</li>
<li><strong>安全である</strong>: 傍受されないよう暗号化され、セキュアであること。Service Worker も HTTPS 環境下のみ配信可能である</li>
<li><strong>発見・特定できる</strong>: <a href=https://w3c.github.io/manifest/>Web App Manifest</a>によってアプリケーションとして確認されること</li>
<li><strong>エンゲージの機会を提供できる</strong>: プッシュ通知などを通じてアプリを使ってもらう機会を促すことができること。<a href=/posts/2015/service-worker-push-notification.html>Web のプッシュ通知は Service Worker で実現される</a></li>
<li><strong>ネイティブアプリのようにインストールできる</strong>: ホームスクリーンに追加され、ユーザーに使ってもらう機会があること。アプリのアイコンを予め用意しておくのはもちろんのこと、<a href=https://w3c.github.io/manifest/>Web App Manifest</a>というマニフェストファイルをアプリに定義しておくことで、<a href=https://developers.google.com/web/updates/2015/03/increasing-engagement-with-app-install-banners-in-chrome-for-android>ブラウザがインストールを促すダイアログを表示</a>できる</li>
<li><strong>URL でリンクできる</strong>: インストールが要らず、URL でアクセスできるという Web の基本であり根幹</li>
</ul>
<p>これらをすべて満たすことが Progressive Web Apps の条件というわけではなく、雑に言えば「こういう Web だと良いよね」という話である。ひと昔前なら <strong>Web では無理だけどネイティブならできること</strong> でもあったので、これからの Web で出来ることの再認識をも唱えている。</p>
<h2 id=service-worker-と-https>Service Worker と HTTPS</h2>
<p>事実上、Service Worker と HTTPS は必須である。Service Worker は HTTPS が前提なのでまず HTTPS ということになるが、HTTPS 化の敷居が証明書の管理や取得のコストと手間のせいでどうしても高い（個人だと特に）。しかし HTTPS 化の波は確実に来ており、様々な所で暗黙の前提になりつつあるので導入を避け続けることができない。無料で証明書を取得できる <a href=https://letsencrypt.org>Let’s Encrypt</a> のようなサービスもあるので、練習がてら積極的に利用していくべきだろう。</p>
<p>また、自身の Web を HTTPS 化しても、サードパーティの HTTP のコンテンツが混在すると表示できないという問題が出てくる。そのサービスにとってクリティカルなコンテンツだとどうしようもなくなる可能性があるが、これが障壁になると Web 全体の HTTPS 化が進まないというジレンマもあるので、難しいところだ。</p>
<p>Progressive Web Apps で唱えられている（もといネイティブアプリの特徴であった）、オフライン化・プッシュ通知・バックグラウンド同期は全て Service Worker によって成り立つものだ。しかしいずれの機能もサービスにとってクリティカルな損失になりにくく（要件次第、設計次第だが）、プログレッシブ・エンハンスメントとして導入しやすい。非機能要件として既存の Web にも追加しやすいので、現在関わっている開発に組み込むことを検討できる。</p>
<h2 id=パフォーマンス>パフォーマンス</h2>
<p>ローディングにおけるアセットのロードについては、Service Worker と Cache API による明示的なキャッシュコントロールによってある程度解決されるだろう。その他のリソース取得に関しても、<a href=http://www.w3.org/TR/resource-hints/>Resource Hints</a> や <a href=http://igrigorik.github.io/http-client-hints/>Client Hints</a> などによる最適化が進んでいる。</p>
<p>ランタイムにおいて Web アプリのパフォーマンスがネイティブアプリのそれを超えることは原理的に無理だが、その差を感じにくくなる時は来る。デスクトップ Web が良い例で、Windows や macOS のネイティブアプリでサービスを展開するケースは少なくなってきている。というより、Web アプリで機能をカバーできるケースが増えている、という方が適切かもしれない。これは、デスクトップ Web でも充分にパフォーマンスが出て、ブラウザで出来る機能も拡充されてきたことが理由にある。Electron や Node-webkit のように Chromium や WebKit がデスクトップアプリの新たなプラットフォームとして再利用されていることにも表れている。</p>
<p>そうなれば1つのソースコードであらゆるプラットフォームに配信できる Web の方が開発時のコストも低く、よりストアに申請することなくスピーディに配信でき、サービスの提供側にも利用側にもメリットが大きい。</p>
<aside class=Share>
<div class=Share__Item>
<button type=button class=Share__Button>🔗 この記事をシェアする</a>
</div>
</aside>
<div popover=auto id=Popover>タイトルと URL をコピーしました</div>
<nav class=Pager>
<div class="Pager__Item Pager__Item--left">
<a href=/posts/2015/wdpress-frontend-series-svg.html>👈 WEB+DB PRESS Vol.90 Webフロントエンド最前線「SVG … マルチデバイスに強く、アニメーションもできる画像フォーマット」</a>
</div>
<div class="Pager__Item Pager__Item--right">
<a href=/posts/2015/bought-in-2015.html>2015年に買って良かったもの 👉</a>
</div>
</nav>
</main>
<aside class=Aside></aside>
<footer class=Footer style=margin-bottom:2%>
<h1>Author</h1>
<div class=Media>
<picture>
<source srcset=/img/1000ch.avif type=image/avif>
<img class=Media__Figure src=/img/1000ch.jpg alt>
</picture>
<div class=Media__Body>
<h3 class=Media__Title>1000ch <a href=https://twitter.com/1000ch class=twitter-follow-button data-show-count=false data-show-screen-name=false>Follow @1000ch</a></h3>
<p>Web アプリケーション開発を専門とするソフトウェアエンジニア。企業で働く傍ら、技術顧問として複数企業のエンジニアリングに関わり、高品質で維持しやすい Web アプリケーションを作るための活動を続けている。</p>
</div>
</div>
</footer>
</div>
<script defer src=https://platform.twitter.com/widgets.js></script>
<script defer src=https://platform.instagram.com/en_US/embeds.js></script>
<script defer src=https://strava-embeds.com/embed.js></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/highlight.min.js></script>
<script type=module>
import AffiliateLink from '/js/affiliate-link.js';

customElements.define('affiliate-link', AffiliateLink);

const autoPhrase = document.querySelector('#auto-phrase');
const darkMode =  document.querySelector('#dark-mode');
autoPhrase.checked = localStorage.getItem('auto-phrase');
darkMode.checked = localStorage.getItem('dark-mode');

autoPhrase.addEventListener('change', event => {
  if (event.target.checked) {
    localStorage.setItem('auto-phrase', true);
  } else {
    localStorage.removeItem('auto-phrase');
  }
});

darkMode.addEventListener('change', event => {
  if (event.target.checked) {
    localStorage.setItem('dark-mode', true);
  } else {
    localStorage.removeItem('dark-mode');
  }
});

document.querySelectorAll('pre code').forEach(block => {
  hljs.highlightBlock(block);
});

document.querySelector('.Share__Item button').addEventListener('click', async event => {
  event.preventDefault();

  const data = {
    title: document.title,
    text: document.title,
    url: location.href
  };

  if (navigator.canShare?.(data)) {
    await navigator.share(data);
  } else {
    await navigator.clipboard?.writeText(`${data.title} ${data.url}`);
    const popover = document.querySelector('#Popover');
    popover.showPopover();

    setTimeout(() => {
      popover.hidePopover();
    }, 2000);
  }
});
</script>
</body>
</html>