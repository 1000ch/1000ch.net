<!doctype html><html lang=ja>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>HTTP1.1とSPDYとHTTP2 - EagleLand</title>
<link rel=icon href=/favicon.png>
<link rel="shortcut icon" href=/favicon.png>
<link rel="shortcut icon" href=/favicon.svg type=image/svg+xml sizes=any>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/dracula.min.css>
<link rel=stylesheet href=/css/settings.css>
<link rel=stylesheet href=/css/tools.css>
<link rel=stylesheet href=/css/generic.css>
<link rel=stylesheet href=/css/base.css>
<link rel=stylesheet href=/css/objects.css>
<link rel=stylesheet href=/css/components.css>
<link rel=stylesheet href=/css/trumps.css>
<link rel=alternate href=/rss.xml title=1000ch.net type=application/rss+xml>
<meta name=author content="Shogo Sensui">
<meta name=copyright content="Copyright (c) Shogo Sensui; Licensed under Creative Commons Attribution-Noncommercial-Share Japan">
<meta property="og:description" content="HTTP1.1とSPDYとHTTP2 Webの通信プロトコルとして普及するHTTPも、HTTP2に向かって大きな変貌を遂げようとしている。最初期のHTTP0.9からどういう変化をたどってきたのか気になったので、調べたメモ。ネットワーク・HTTPの予備知識にWebにおけるネットワーク通信もどうぞ。
各プロトコルの特徴 HTTP0.9からHTTP1.0になった辺は割愛。ログイン状態みたいに状態を保持する機構のためにCookieが登場したり、80番ポートがデフォルトになったりしたのはこの辺りらしい。
HTTP1.0からHTTP1.1にかけてとそれ以降は、急速に進化し肥大化してきたWebコンテンツを支えるための変遷。データは大きくなるし、リクエストも増加の一途を辿ってきたのでネットワークにも進化が要求されている。
HTTP1.1  IPアドレスだけでなくホスト名で通信相手を特定できるようになった（HOSTヘッダのサポート） TCP接続を維持する機能が追加された（Keep-Alive） リクエストヘッダー・レスポンスヘッダーがテキストフォーマット ひとつのTCPコネクションにつき、ひとつのリクエストとレスポンス それぞれのTCP接続が独立して輻輳制御を行っている  SPDY  HTTPをベースに高速化が図られた、Googleが開発するプロトコル HTTP1.1の作法は変わらないので互換性があり、既存環境とも共存できる 接続手順やセッション管理といった部分の効率化がなされた セッション層を使うためTLSが必須、つまりHTTPS環境において利用可能 TLS連携からのプロトコル自動選択や、HTTPヘッダの圧縮 HTTP2に継承された通信の優先度付多重化とサーバープッシュ  HTTP2  SPDYをベースに考案されたプロトコル リクエストヘッダー・レスポンスヘッダーがバイナリフォーマット ひとつのTCPコネクションにつき、複数のリクエストとレスポンスが可能（仮想ストリームチャネルによる多重化） クライアントからのリクエストがなくともレスポンスをプッシュできる（サーバープッシュ） ストリームに優先度を指定可能で、後方のリクエストでも前方のリクエストより優先度が高ければそちらを優先して返却する（HTTP2プライオリティ） ブラウザでは最新のChromeとFirefoxで有効であり、IEではテクニカルプレビュー HTTP・HTTPS（平文でもOK）を問わず、TLS利用は必須ではない chrome://net-internals/#spdy  仕様策定については、RFC標準化目前ぽい。IETFのHTTPワーキンググループがメンテナンスしているHTTP2の公式サイトにも、デカデカと書かれている。
 IETF Last Call HTTP/2 and HPACK are currently in IETF Last Call.
 HTTP/2とService Workerで実現するWeb Push Service Workerに関する仕様とか機能とかの最後で触れているが、Push APIというものがある。こちらはお待ちかねのWebでPushを実現するAPIだが、このサーバーから送られるメッセージはService Workerが受け取る、つまりPush APIの利用にはService Workerが要るわけだ。更に、HTTP1.1まで出来なかったサーバーからのPushは、HTTP2の双方向シーケンスによって可能になる。何が言いたいかというと、Web Pushは両者によって初めて成り立つ機能ということ。以下、ざっくりとした手順。
 Service Workerがプッシュサーバーに対し、クライアントの登録をする プッシュサーバーにポーリングしつつ、通知用のプッシュチャネルを作成する プッシュサーバーへの登録情報をアプリケーションサーバーに登録する アプリケーションサーバーに通知イベントが発生したら、プッシュサーバーにデータを渡す 通知用に作成されたプッシュチャネルを使って、プッシュサーバーからService Workerにデータを渡す  詳細はService WorkerとHTTP/2が切り開く新しいWeb Pushの世界という記事を見て下さい。死ぬほどわかりやすいです。">
<meta property="og:image" content="https://1000ch.net/img/apple-touch-icon.png">
<meta name=twitter:card content="summary">
<meta property="og:type" content="article">
<meta property="og:url" content="https://1000ch.net/posts/2015/http-spdy-http2.html">
<meta property="og:site_name" content="EagleLand">
<meta property="og:title" content="HTTP1.1とSPDYとHTTP2">
<meta name=twitter:site content="@1000ch">
<meta name=twitter:url content="https://1000ch.net/posts/2015/http-spdy-http2.html">
<meta name=twitter:title content="HTTP1.1とSPDYとHTTP2">
<meta name=google-site-verification content="BWewniqiBzRmrhpj51eLwug-F4hamFfyznl-ARb-Y4Y">
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon.png>
<link rel=apple-touch-icon-precomposed sizes=114x114 href=/img/apple-touch-icon.png>
<link rel=apple-touch-icon-precomposed sizes=72x72 href=/img/apple-touch-icon.png>
<link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png>
<script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-49530352-1','1000ch.net'),ga('send','pageview')</script>
</head>
<body>
<div class=Container>
<header class=Header>
<h1 class=Header__Title>
<a href=/>EagleLand</a>
</h1>
<nav class=Header__Menu>
<div class=Header__MenuItem>
<a href=/rss.xml>📻 RSS</a>
</div>
<div class=Header__MenuItem>
<a href="https://www.google.co.jp/search?q=site%3A1000ch.net">🔍 検索</a>
</div>
<div class=Header__MenuItem>
<a href=https://shogosensui.com>🌎 Who is 1000ch</a>
</div>
</nav>
<div class=Preference>
<label>
<input type=checkbox switch id=auto-phrase> 日本語のフレーズ改行
</label>
<label>
<input type=checkbox switch id=dark-mode> ダークモード
</label>
</div>
</header>
<main class=Main>
<span class="Label Label--gray pull-left">2015.01.29</span>
<h1 id=http11とspdyとhttp2>HTTP1.1とSPDYとHTTP2</h1>
<p>Webの通信プロトコルとして普及するHTTPも、HTTP2に向かって大きな変貌を遂げようとしている。最初期のHTTP0.9からどういう変化をたどってきたのか気になったので、調べたメモ。ネットワーク・HTTPの予備知識に<a href=/posts/2014/networking-in-web.html>Webにおけるネットワーク通信</a>もどうぞ。</p>
<h2 id=各プロトコルの特徴>各プロトコルの特徴</h2>
<p>HTTP0.9からHTTP1.0になった辺は割愛。ログイン状態みたいに状態を保持する機構のためにCookieが登場したり、80番ポートがデフォルトになったりしたのはこの辺りらしい。</p>
<p>HTTP1.0からHTTP1.1にかけてとそれ以降は、急速に進化し肥大化してきたWebコンテンツを支えるための変遷。データは大きくなるし、リクエストも増加の一途を辿ってきたのでネットワークにも進化が要求されている。</p>
<h3 id=http11>HTTP1.1</h3>
<ul>
<li>IPアドレスだけでなくホスト名で通信相手を特定できるようになった（HOSTヘッダのサポート）</li>
<li>TCP接続を維持する機能が追加された（Keep-Alive）</li>
<li>リクエストヘッダー・レスポンスヘッダーがテキストフォーマット</li>
<li>ひとつのTCPコネクションにつき、ひとつのリクエストとレスポンス</li>
<li>それぞれのTCP接続が独立して<a href=http://ja.wikipedia.org/wiki/%E8%BC%BB%E8%BC%B3%E5%88%B6%E5%BE%A1>輻輳制御</a>を行っている</li>
</ul>
<h3 id=spdy>SPDY</h3>
<ul>
<li>HTTPをベースに高速化が図られた、Googleが開発するプロトコル</li>
<li>HTTP1.1の作法は変わらないので互換性があり、既存環境とも共存できる</li>
<li>接続手順やセッション管理といった部分の効率化がなされた</li>
<li>セッション層を使うためTLSが必須、つまりHTTPS環境において利用可能</li>
<li>TLS連携からのプロトコル自動選択や、HTTPヘッダの圧縮</li>
<li>HTTP2に継承された通信の優先度付多重化とサーバープッシュ</li>
</ul>
<h3 id=http2>HTTP2</h3>
<ul>
<li>SPDYをベースに考案されたプロトコル</li>
<li>リクエストヘッダー・レスポンスヘッダーがバイナリフォーマット</li>
<li>ひとつのTCPコネクションにつき、複数のリクエストとレスポンスが可能（仮想ストリームチャネルによる多重化）</li>
<li>クライアントからのリクエストがなくともレスポンスをプッシュできる（サーバープッシュ）</li>
<li>ストリームに優先度を指定可能で、後方のリクエストでも前方のリクエストより優先度が高ければそちらを優先して返却する（HTTP2プライオリティ）</li>
<li>ブラウザでは最新のChromeとFirefoxで有効であり、IEではテクニカルプレビュー</li>
<li>HTTP・HTTPS（平文でもOK）を問わず、TLS利用は必須ではない</li>
<li>chrome://net-internals/#spdy</li>
</ul>
<p>仕様策定については、RFC標準化目前ぽい。IETFのHTTPワーキンググループがメンテナンスしている<a href=http://http2.github.io/>HTTP2の公式サイト</a>にも、デカデカと書かれている。</p>
<blockquote>
<h2 id=ietf-last-call>IETF Last Call</h2>
<p>HTTP/2 and HPACK are currently in IETF Last Call.</p>
</blockquote>
<h2 id=http2とservice-workerで実現するweb-push>HTTP/2とService Workerで実現するWeb Push</h2>
<p><a href=/posts/2014/service-worker-internals.html>Service Workerに関する仕様とか機能とか</a>の最後で触れているが、<a href=https://w3c.github.io/push-api/>Push API</a>というものがある。こちらはお待ちかねのWebでPushを実現するAPIだが、このサーバーから送られるメッセージはService Workerが受け取る、つまりPush APIの利用にはService Workerが要るわけだ。更に、HTTP1.1まで出来なかったサーバーからのPushは、HTTP2の双方向シーケンスによって可能になる。何が言いたいかというと、Web Pushは両者によって初めて成り立つ機能ということ。以下、ざっくりとした手順。</p>
<ol>
<li>Service Workerがプッシュサーバーに対し、クライアントの登録をする</li>
<li>プッシュサーバーにポーリングしつつ、通知用のプッシュチャネルを作成する</li>
<li>プッシュサーバーへの登録情報をアプリケーションサーバーに登録する</li>
<li>アプリケーションサーバーに通知イベントが発生したら、プッシュサーバーにデータを渡す</li>
<li>通知用に作成されたプッシュチャネルを使って、プッシュサーバーからService Workerにデータを渡す</li>
</ol>
<p>詳細は<a href=http://d.hatena.ne.jp/jovi0608/20141204/1417697480>Service WorkerとHTTP/2が切り開く新しいWeb Pushの世界</a>という記事を見て下さい。死ぬほどわかりやすいです。</p>
<p>双方向通信といえばWebSocketを思い出す。Service WorkerコンテキストにもWebSocketはいるみたいだし、同じようなことをWebSocketでやる話ってあるんだろうか。HTTP2でWebSocketを取り込む話をどこかでチラッと見かけた気がする。けど、気のせいかもしれない。この辺の情報、誰か下さい(´・ω・`)</p>
<h2 id=参考リソース>参考リソース</h2>
<ul>
<li><a href=http://www.chromium.org/spdy>SPDY - The Chromium Projects</a></li>
<li><a href=http://www.slideshare.net/shigeki_ohtsu/http2-ohtsu-html5conf2015>HTTP/2の現状とこれから</a> - SlideShare 2015年1月25日</li>
<li><a href=https://blog.httpwatch.com/2015/01/16/a-simple-performance-comparison-of-https-spdy-and-http2/>A Simple Performance Comparison of HTTPS, SPDY and HTTP/2</a> - HttpWatch 2015年1月16日</li>
<li><a href=http://blog.summerwind.jp/archives/2566>HTTP/2 を追いかけて</a> - SummerWind 2014年12月25日</li>
<li><a href=http://d.hatena.ne.jp/jovi0608/20141204/1417697480>Service WorkerとHTTP/2が切り開く新しいWeb Pushの世界</a> - 2014年12月4日</li>
<li><a href=http://techblog.yahoo.co.jp/infrastructure/http2/introduction_to_http2/>HTTP/2 入門</a> - Yahoo Developer Network 2014年6月19日</li>
<li><a href=http://www.iij.ad.jp/company/development/tech/activities/spdy/index.html>Web表示の高速化を実現するSPDYとHTTP/2.0の標準化</a> - IIJ 2013年8月6日</li>
<li><a href=http://html5experts.jp/komasshu/404/>変わるWebプロトコルの常識（SPDY, HTTP2.0編）</a> - HTML5Experts.jp 2013年7月9日</li>
</ul>
<aside class=Share>
<div class=Share__Item>
<button type=button class=Share__Button>🔗 この記事をシェアする</a>
</div>
</aside>
<div popover=auto id=Popover>タイトルと URL をコピーしました</div>
<nav class=Pager>
<div class="Pager__Item Pager__Item--left">
<a href=/posts/2015/high-performance-javascript.html>👈 ハイパフォーマンスJavaScript</a>
</div>
<div class="Pager__Item Pager__Item--right">
<a href=/posts/2015/polymer-is.html>Polymerについての所感 👉</a>
</div>
</nav>
</main>
<aside class=Aside></aside>
<footer class=Footer style=margin-bottom:2%>
<h1>Author</h1>
<div class=Media>
<picture>
<source srcset=/img/1000ch.avif type=image/avif>
<img class=Media__Figure src=/img/1000ch.jpg alt>
</picture>
<div class=Media__Body>
<h3 class=Media__Title>1000ch <a href=https://twitter.com/1000ch class=twitter-follow-button data-show-count=false data-show-screen-name=false>Follow @1000ch</a></h3>
<p>Web アプリケーション開発を専門とするソフトウェアエンジニア。企業で働く傍ら、技術顧問として複数企業のエンジニアリングに関わり、高品質で維持しやすい Web アプリケーションを作るための活動を続けている。</p>
</div>
</div>
</footer>
</div>
<script defer src=https://platform.twitter.com/widgets.js></script>
<script defer src=https://platform.instagram.com/en_US/embeds.js></script>
<script defer src=https://strava-embeds.com/embed.js></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/highlight.min.js></script>
<script type=module>
import AffiliateLink from '/js/affiliate-link.js';

customElements.define('affiliate-link', AffiliateLink);

const autoPhrase = document.querySelector('#auto-phrase');
const darkMode =  document.querySelector('#dark-mode');
autoPhrase.checked = localStorage.getItem('auto-phrase');
darkMode.checked = localStorage.getItem('dark-mode');

autoPhrase.addEventListener('change', event => {
  if (event.target.checked) {
    localStorage.setItem('auto-phrase', true);
  } else {
    localStorage.removeItem('auto-phrase');
  }
});

darkMode.addEventListener('change', event => {
  if (event.target.checked) {
    localStorage.setItem('dark-mode', true);
  } else {
    localStorage.removeItem('dark-mode');
  }
});

document.querySelectorAll('pre code').forEach(block => {
  hljs.highlightBlock(block);
});

document.querySelector('.Share__Item button').addEventListener('click', async event => {
  event.preventDefault();

  const data = {
    title: document.title,
    text: document.title,
    url: location.href
  };

  if (navigator.canShare?.(data)) {
    await navigator.share(data);
  } else {
    await navigator.clipboard?.writeText(`${data.title} ${data.url}`);
    const popover = document.querySelector('#Popover');
    popover.showPopover();

    setTimeout(() => {
      popover.hidePopover();
    }, 2000);
  }
});
</script>
</body>
</html>