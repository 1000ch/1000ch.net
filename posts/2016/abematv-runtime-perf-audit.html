<!doctype html><html lang=ja>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>AbemaTVのランタイムパフォーマンスのAudit - EagleLand</title>
<link rel=icon href=/favicon.png>
<link rel="shortcut icon" href=/favicon.png>
<link rel="shortcut icon" href=/favicon.svg type=image/svg+xml sizes=any>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/dracula.min.css>
<link rel=stylesheet href=/css/settings.css>
<link rel=stylesheet href=/css/tools.css>
<link rel=stylesheet href=/css/generic.css>
<link rel=stylesheet href=/css/base.css>
<link rel=stylesheet href=/css/objects.css>
<link rel=stylesheet href=/css/components.css>
<link rel=stylesheet href=/css/trumps.css>
<link rel=alternate href=/rss.xml title=1000ch.net type=application/rss+xml>
<meta name=author content="Shogo Sensui">
<meta name=copyright content="Copyright (c) Shogo Sensui; Licensed under Creative Commons Attribution-Noncommercial-Share Japan">
<meta property="og:description" content="AbemaTVのランタイムパフォーマンスのAudit 最近業務で、巷で話題のAbemaTVのパフォーマンス改善をしている。個別具体性が高いが調査改善の雰囲気を感じ取ってもらえればそれで良いかと思い、記事にした。
AbemaTVのフロントエンドの構成 話の前提となるAbemaTVのフロントエンドの構成は次の通りで、まさに流行りのといった感じ。
 facebook/react facebook/immutable-js Reactive-Extensions/RxJS reactjs/react-router css-modules/css-modules  ビルド周りはbabelとwebpack、あとはlintツールがちょこちょこ入ったりしている。この改善の話と関係してくるのは、ReactとImmutableJSとRxJSだけ。
番組再生画面のコメント開閉が重い 今回ケーススタディとして挙げるのは番組再生画面のコメント開閉機能。
再生されている内容は無視してもらってGIFアニメの通り、右下のコメントアイコンを押してコメントを開閉するアクションがある。FPSが低くてわかりにくいが、クリック後に200ms程遅延した後にようやく右からコメント領域がせり出てくる。会社の高スペックなMacBook Proでこの状態なので、これはマズい。
コメント領域を全て開くまでに200msかかっている クリック後の反応は速いが、アニメーションの最中に何かにつっかかる。コメントを表示して非表示にする一連の処理を、DevToolsのTimelineで計測してみると以下の様な結果が得られた。
見たところスクリプト処理（黄色い部分）がアニメーション処理（紫色の部分）の手前で邪魔をしていることがわかる。200ms全てスクリプト処理に持って行かれているので、FPSは0の状態が続いている。応じて、メモリもピークまで達したあとガクッと低下している。
アニメーション処理そのものの負荷 先程のタイムラインを見てもわかるように、アニメーション処理そのものの負荷は低い。DevToolsのドロワーメニューのRenderingタブに、 Paint Flashing と Layers Borders というメニューがあるので、これらにチェックをすると画面上に緑色の領域（描画処理が発生している領域）と、オレンジ色の枠（レイヤの境界線）が表れる。この状態でコメントの表示・非表示を切り替えてみる。
すると、コメントの領域はオレンジ色の枠で囲まれているだけで、緑色にはなっておらず描画処理は行われていないことがわかる。この時点で、コメント領域は既に描画されているが画面内に入っておらず、アイコンがクリックされたタイミングでアニメーションしながら表示されることがわかる。アニメーションのタイミングでは描画処理が行われていない（というと語弊がありそうだが）ので、GPUでテクスチャ化されているものが動いているだけということもわかる。
CSSを確認してみると、以下のようになっていた。
.right-slide-base { height: 100%; overflow: hidden; position: fixed; right: 0; top: 0; transform: translateX(100%); transition: transform var(--duration) var(--ease-out-cubic); z-index: var(--z-footer); } .right-comment-area { composes: right-slide-base; background-color: var(--lt-bg-regular); width: 310px; } .right-slide--shown { transform: translateX(0); } 予想通り、クリック時.right-slide--shownを付け外すことでtransformX(n)で表示状態を切り替えている。これならば.right-comment-areaが適用されている要素が変化しビットマップが更新されない限り、アニメーションによる再描画は発生しない。コメント表示は、機能としてポーリングで新しいコメントをロードするようになっているので、GPUに再度送っちゃう問題が起こりそうだが、一旦置いておく。
開閉に伴うスクリプト処理 クリック時のスクリプト処理を抜粋。
showCommentList(toShow = true) { this.">
<meta property="og:image" content="https://1000ch.net/img/posts/2016/abematv-runtime-perf-audit/timeline.png">
<meta name=twitter:card content="summary_large_image">
<meta property="og:type" content="article">
<meta property="og:url" content="https://1000ch.net/posts/2016/abematv-runtime-perf-audit.html">
<meta property="og:site_name" content="EagleLand">
<meta property="og:title" content="AbemaTVのランタイムパフォーマンスのAudit">
<meta name=twitter:site content="@1000ch">
<meta name=twitter:url content="https://1000ch.net/posts/2016/abematv-runtime-perf-audit.html">
<meta name=twitter:title content="AbemaTVのランタイムパフォーマンスのAudit">
<meta name=google-site-verification content="BWewniqiBzRmrhpj51eLwug-F4hamFfyznl-ARb-Y4Y">
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon.png>
<link rel=apple-touch-icon-precomposed sizes=114x114 href=/img/apple-touch-icon.png>
<link rel=apple-touch-icon-precomposed sizes=72x72 href=/img/apple-touch-icon.png>
<link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png>
<script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-49530352-1','1000ch.net'),ga('send','pageview')</script>
</head>
<body>
<div class=Container>
<header class=Header>
<h1 class=Header__Title>
<a href=/>EagleLand</a>
</h1>
<nav class=Header__Menu>
<div class=Header__MenuItem>
<a href=/rss.xml>📻 RSS</a>
</div>
<div class=Header__MenuItem>
<a href="https://www.google.co.jp/search?q=site%3A1000ch.net">🔍 検索</a>
</div>
<div class=Header__MenuItem>
<a href=https://shogosensui.com>🌎 Who is 1000ch</a>
</div>
</nav>
</header>
<main class=Main>
<span class="Label Label--gray pull-left">2016.05.17</span>
<h1 id=abematvのランタイムパフォーマンスのaudit>AbemaTVのランタイムパフォーマンスのAudit</h1>
<p>最近業務で、巷で話題の<a href=https://abema.tv/>AbemaTV</a>のパフォーマンス改善をしている。個別具体性が高いが調査改善の雰囲気を感じ取ってもらえればそれで良いかと思い、記事にした。</p>
<h2 id=abematvのフロントエンドの構成>AbemaTVのフロントエンドの構成</h2>
<p>話の前提となるAbemaTVのフロントエンドの構成は次の通りで、まさに流行りのといった感じ。</p>
<ul>
<li><a href=https://github.com/facebook/react>facebook/react</a></li>
<li><a href=https://facebook.github.io/immutable-js/>facebook/immutable-js</a></li>
<li><a href=https://github.com/Reactive-Extensions/RxJS>Reactive-Extensions/RxJS</a></li>
<li><a href=https://github.com/reactjs/react-router>reactjs/react-router</a></li>
<li><a href=https://github.com/css-modules/css-modules>css-modules/css-modules</a></li>
</ul>
<p>ビルド周りは<a href=https://babeljs.io/>babel</a>と<a href=https://webpack.github.io/>webpack</a>、あとはlintツールがちょこちょこ入ったりしている。この改善の話と関係してくるのは、ReactとImmutableJSとRxJSだけ。</p>
<h2 id=番組再生画面のコメント開閉が重い>番組再生画面のコメント開閉が重い</h2>
<p>今回ケーススタディとして挙げるのは番組再生画面のコメント開閉機能。</p>
<p><img src=/img/posts/2016/abematv-runtime-perf-audit/comment.gif alt></p>
<p>再生されている内容は無視してもらってGIFアニメの通り、右下のコメントアイコンを押してコメントを開閉するアクションがある。FPSが低くてわかりにくいが、クリック後に200ms程遅延した後にようやく右からコメント領域がせり出てくる。会社の高スペックなMacBook Proでこの状態なので、これはマズい。</p>
<h2 id=コメント領域を全て開くまでに200msかかっている>コメント領域を全て開くまでに200msかかっている</h2>
<p>クリック後の反応は速いが、アニメーションの最中に何かにつっかかる。コメントを表示して非表示にする一連の処理を、DevToolsのTimelineで計測してみると以下の様な結果が得られた。</p>
<p><img src=/img/posts/2016/abematv-runtime-perf-audit/timeline.png alt></p>
<p>見たところスクリプト処理（黄色い部分）がアニメーション処理（紫色の部分）の手前で邪魔をしていることがわかる。200ms全てスクリプト処理に持って行かれているので、FPSは0の状態が続いている。応じて、メモリもピークまで達したあとガクッと低下している。</p>
<h3 id=アニメーション処理そのものの負荷>アニメーション処理そのものの負荷</h3>
<p>先程のタイムラインを見てもわかるように、アニメーション処理そのものの負荷は低い。DevToolsのドロワーメニューのRenderingタブに、 <strong>Paint Flashing</strong> と <strong>Layers Borders</strong> というメニューがあるので、これらにチェックをすると画面上に緑色の領域（描画処理が発生している領域）と、オレンジ色の枠（レイヤの境界線）が表れる。この状態でコメントの表示・非表示を切り替えてみる。</p>
<p><img src=/img/posts/2016/abematv-runtime-perf-audit/devtools-drawer.png alt></p>
<p>すると、コメントの領域はオレンジ色の枠で囲まれているだけで、緑色にはなっておらず描画処理は行われていないことがわかる。この時点で、コメント領域は既に描画されているが画面内に入っておらず、アイコンがクリックされたタイミングでアニメーションしながら表示されることがわかる。アニメーションのタイミングでは描画処理が行われていない（というと語弊がありそうだが）ので、GPUでテクスチャ化されているものが動いているだけということもわかる。</p>
<p><img src=/img/posts/2016/abematv-runtime-perf-audit/comment-animation.gif alt></p>
<p>CSSを確認してみると、以下のようになっていた。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css>.<span style=color:#a6e22e>right-slide-base</span> {
  <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
  <span style=color:#66d9ef>overflow</span>: <span style=color:#66d9ef>hidden</span>;
  <span style=color:#66d9ef>position</span>: <span style=color:#66d9ef>fixed</span>;
  <span style=color:#66d9ef>right</span>: <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>top</span>: <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>transform</span>: translateX(<span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>);
  <span style=color:#66d9ef>transition</span>: <span style=color:#66d9ef>transform</span> <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>duration) <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span><span style=color:#66d9ef>ease-out</span><span style=color:#f92672>-</span>cubic);
  <span style=color:#66d9ef>z-index</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>z<span style=color:#f92672>-</span>footer);
}

.<span style=color:#a6e22e>right-comment-area</span> {
  composes: <span style=color:#66d9ef>right</span><span style=color:#f92672>-</span>slide-base;
  <span style=color:#66d9ef>background-color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>lt<span style=color:#f92672>-</span>bg<span style=color:#f92672>-</span>regular);
  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>310</span><span style=color:#66d9ef>px</span>;
}

.<span style=color:#a6e22e>right-slide--shown</span> {
  <span style=color:#66d9ef>transform</span>: translateX(<span style=color:#ae81ff>0</span>);
}
</code></pre></div><p>予想通り、クリック時<code>.right-slide--shown</code>を付け外すことで<code>transformX(n)</code>で表示状態を切り替えている。これならば<code>.right-comment-area</code>が適用されている要素が変化しビットマップが更新されない限り、アニメーションによる再描画は発生しない。コメント表示は、機能としてポーリングで新しいコメントをロードするようになっているので、GPUに再度送っちゃう問題が起こりそうだが、一旦置いておく。</p>
<h3 id=開閉に伴うスクリプト処理>開閉に伴うスクリプト処理</h3>
<p>クリック時のスクリプト処理を抜粋。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>showCommentList</span>(<span style=color:#a6e22e>toShow</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>) {
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>closeAll</span>();
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>showElement</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>refs</span>.<span style=color:#a6e22e>commentList</span>, <span style=color:#a6e22e>toShow</span>);

  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>metaSlotId</span>) <span style=color:#66d9ef>return</span>;
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>toShow</span>) {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>fetchComment</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>metaSlotId</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>metaData</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;channelId&#34;</span>));
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mergeComments</span>();
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>commentFetchSubscription</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Rx</span>.<span style=color:#a6e22e>Observable</span>.<span style=color:#a6e22e>interval</span>(<span style=color:#a6e22e>POLLING_INTERVAL</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>CONVERSIONS</span>.<span style=color:#a6e22e>sec</span>)
      .<span style=color:#a6e22e>subscribe</span>(() =&gt; {
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>metaSlotId</span>) <span style=color:#66d9ef>return</span>;
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>fetchComment</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>metaSlotId</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>metaData</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;channelId&#34;</span>));
      });
  } <span style=color:#66d9ef>else</span> {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>fetchSlotAudience</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>metaSlotId</span>);
    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>commentFetchSubscription</span>) {
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>commentFetchSubscription</span>.<span style=color:#a6e22e>dispose</span>();
    }
  }
}
</code></pre></div><p><code>this.showElement()</code>で先程の<code>.right-slide--shown</code>を付け外していて、その後のコメントデータを取得している。ここが重そうな予感がする。</p>
<p>表示の時（<code>toShow</code>が<code>true</code>のとき）に行われる<code>this.fetchComment()</code>で、コメントデータをサーバーから取得している。サーバーレスポンスが重いのかどうかの確認のため、対象のリクエストをNetworkパネルで確認する。</p>
<p><img src=/img/posts/2016/abematv-runtime-perf-audit/fetch-comment.png alt></p>
<p>Waitingが36msということで、大きな問題は無さそう。</p>
<p>では、Timelineから問題が見受けられていたスクリプト処理をプロファイルしてみる。</p>
<p><img src=/img/posts/2016/abematv-runtime-perf-audit/cpu-profile.png alt></p>
<p>すると<code>storeComment()</code>という関数で200msかかっているおり、その配下で2回コールされている<code>setState()</code>にそれぞれ100msかかっていることがわかる。<code>storeComment()</code>は<code>this.fetchComment()</code>内でコールしているアクションで呼び出され、subscriberに対してdispatchしている様子。</p>
<p>案の定<code>subscribe()</code>のコールバックで<code>setState()</code>が複数回実行されていて、状態に依っては3回以上コールされそうな状態だった。これを直す。</p>
<h2 id=開閉処理のチューニング>開閉処理のチューニング</h2>
<p>ここからローカル環境で色々直していくので本番環境で計測したものとは異なってくる。ローカル環境で計測したチューニング前の結果は以下の状態。</p>
<p><img src=/img/posts/2016/abematv-runtime-perf-audit/before.png alt></p>
<h3 id=react-componentのsetstateを複数回コールしないようにする>React Componentの<code>setState()</code>を複数回コールしないようにする</h3>
<p><a href=https://facebook.github.io/react/docs/component-api.html#setstate>React Componentの<code>setState()</code></a>は実行される度に<code>render()</code>が呼ばれる。<code>render()</code>が呼ばれると、VirtualDOMを生成して現在のものと比較し、diffに応じてHTMLに対してバッチを実行するので、<code>setState()</code>を不要に実行してはならない。Reactのパフォーマンスが良いというのはHTMLをいざ更新するときにブラウザの仕事を最小限に留めてくれるという話であって、React内部はそれなりの仕事をしてメモリも食うので、取り扱いは慎重にする。</p>
<p>問題が発生しているコンポーネントでは<code>setState()</code>を何度も呼ばないように修正出来そう。<code>setState()</code>の実行を最小限にした状態で計測したのがこちら。</p>
<p><img src=/img/posts/2016/abematv-runtime-perf-audit/merge-setState.png alt></p>
<p>実行時間がおよそ半分になっているのがわかる。</p>
<h3 id=immutablejsのtojsがハイコストなのでなるべくコールしないようにする>ImmutableJSの<code>toJS()</code>がハイコストなのでなるべくコールしないようにする</h3>
<p>これも調査中に発覚したことだが、JavaScriptネイティブなデータとImmutableJSなデータへの、<code>toJS()</code>と<code>fromJS()</code>による相互変換処理が重い。当然ながらデータの量に比例して更に重くなっていく。</p>
<p>プロジェクトの元々の設計方針としては、ComponentのstateにはImmutableなデータを格納し、<code>render()</code>で<code>toJS()</code>を実行して<code>Map</code>や<code>List</code>をJavaScriptネイティブなデータに変換するというものだった。コードは次のようなイメージ。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Component</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>Component</span> {
  <span style=color:#75715e>// stateのデータはImmutableなデータ
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>foo</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>Map</span>(),
    <span style=color:#a6e22e>bar</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>List</span>()
  };

  <span style=color:#a6e22e>subscriptions</span> <span style=color:#f92672>=</span> [];

  <span style=color:#a6e22e>componentDidMount</span>() {
    <span style=color:#75715e>// FooStoreやBarStoreのsubscribeのコールバックには
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Immutableなデータが流れてくるのでそのままsetState()
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>subscriptions</span>.<span style=color:#a6e22e>push</span>(
      <span style=color:#a6e22e>FooStore</span>.<span style=color:#a6e22e>foo$</span>.<span style=color:#a6e22e>subscribe</span>(<span style=color:#a6e22e>foo</span> =&gt; {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setState</span>({ <span style=color:#a6e22e>foo</span> });
      })
    );

    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>subscriptions</span>.<span style=color:#a6e22e>push</span>(
      <span style=color:#a6e22e>BarStore</span>.<span style=color:#a6e22e>bar$</span>.<span style=color:#a6e22e>subscribe</span>(<span style=color:#a6e22e>bar</span> =&gt; {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setState</span>({ <span style=color:#a6e22e>bar</span> });
      })
    );
  }

  <span style=color:#a6e22e>render</span>() {
    <span style=color:#75715e>// render()の度にImmutableなデータをtoJS()
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>foo</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>toJS</span>();
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>bar</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>bar</span>.<span style=color:#a6e22e>toJS</span>();

    <span style=color:#66d9ef>return</span> (
      <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>div</span><span style=color:#f92672>&gt;</span>
        <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>h1</span><span style=color:#f92672>&gt;</span>{<span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>text</span>}<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/h1&gt;</span>
        <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>p</span><span style=color:#f92672>&gt;</span>{<span style=color:#a6e22e>bar</span>.<span style=color:#a6e22e>text</span>}<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/p&gt;</span>
      <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/div&gt;</span>
    );
  }
}
</code></pre></div><p>この構造の問題は、FooStoreの変更通知で<code>setState()</code>している<code>foo</code>だけでなく、変更されていない<code>bar</code>も<code>render()</code>で<code>toJS()</code>を実行してしまっている点だ。実際にはsubscriptionsはこれよりずっと多いので、更に顕著になる。</p>
<p>重い重い<code>toJS()</code>の実行は最低限にしたいので、Componentのstateに入れるデータはJavaScriptネイティブの<code>Object</code>やら<code>Array</code>などにして、<code>setState()</code>でデータを更新する時に対象データだけ<code>toJS()</code>を実行するようにし、<code>render()</code>では実行しないように変える。「stateにImmutableなデータを保持するべきかどうか」という設計の話も大事だが、パフォーマンスで実害が出ているので開発者全体に合意を取る。</p>
<p>変更後イメージは以下の通り。これで<code>toJS()</code>の実行は必要最低限になった。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Component</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>Component</span> {
  <span style=color:#75715e>// stateのデータはJavaScriptネイティブなデータ
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>foo</span> <span style=color:#f92672>:</span> {},
    <span style=color:#a6e22e>bar</span> <span style=color:#f92672>:</span> []
  };

  <span style=color:#a6e22e>subscriptions</span> <span style=color:#f92672>=</span> [];

  <span style=color:#a6e22e>componentDidMount</span>() {
    <span style=color:#75715e>// FooStoreやBarStoreのsubscribeのコールバックには
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Immutableなデータが流れてくるのでtoJS()してsetState()
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>subscriptions</span>.<span style=color:#a6e22e>push</span>(
      <span style=color:#a6e22e>FooStore</span>.<span style=color:#a6e22e>foo$</span>.<span style=color:#a6e22e>subscribe</span>(<span style=color:#a6e22e>foo</span> =&gt; {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setState</span>({ <span style=color:#a6e22e>foo</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>toJS</span>() });
      })
    );

    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>subscriptions</span>.<span style=color:#a6e22e>push</span>(
      <span style=color:#a6e22e>BarStore</span>.<span style=color:#a6e22e>bar$</span>.<span style=color:#a6e22e>subscribe</span>(<span style=color:#a6e22e>bar</span> =&gt; {
        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setState</span>({ <span style=color:#a6e22e>bar</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>bar</span>.<span style=color:#a6e22e>toJS</span>() });
      })
    );
  }

  <span style=color:#a6e22e>render</span>() {
    <span style=color:#66d9ef>return</span> (
      <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>div</span><span style=color:#f92672>&gt;</span>
        <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>h1</span><span style=color:#f92672>&gt;</span>{<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>text</span>}<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/h1&gt;</span>
        <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>p</span><span style=color:#f92672>&gt;</span>{<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>bar</span>.<span style=color:#a6e22e>text</span>}<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/p&gt;</span>
      <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/div&gt;</span>
    );
  }
}
</code></pre></div><p>諸々修正して計測した結果は以下の通り。</p>
<p><img src=/img/posts/2016/abematv-runtime-perf-audit/dont-use-Immutable.png alt></p>
<p>元々130msだったのが9msまで速くなったということで、CPUに優しいプログラムになった。本番へは近日中にリリースされるでしょう。めでたしめでたし。</p>
<p>※この記事の内容と似たような方針で<a href=https://abema.tv/timetable>番組表</a>のパフォーマンスも色々直したが、効果適面だった。</p>
<aside class=Share>
<div class=Share__Item>
<button type=button class=Share__Button>🔗 この記事をシェアする</a>
</div>
</aside>
<div popover=auto id=Popover>タイトルと URL をコピーしました</div>
<nav class=Pager>
<div class="Pager__Item Pager__Item--left">
<a href=/posts/2016/intersection-observer-lazyload.html>👈 IntersectionObserverを使ってlazyload-imageを書き直した</a>
</div>
<div class="Pager__Item Pager__Item--right">
<a href=/posts/2016/waterproof-hoodies.html>水を弾くコットンパーカー 👉</a>
</div>
</nav>
</main>
<aside class=Aside></aside>
<footer class=Footer style=margin-bottom:2%>
<h1>Author</h1>
<div class=Media>
<picture>
<source srcset=/img/1000ch.avif type=image/avif>
<img class=Media__Figure src=/img/1000ch.jpg alt>
</picture>
<div class=Media__Body>
<h3 class=Media__Title>1000ch <a href=https://twitter.com/1000ch class=twitter-follow-button data-show-count=false data-show-screen-name=false>Follow @1000ch</a></h3>
<p>Web アプリケーション開発を専門とするソフトウェアエンジニア。企業で働く傍ら、技術顧問として複数企業のエンジニアリングに関わり、高品質で維持しやすい Web アプリケーションを作るための活動を続けている。</p>
</div>
</div>
</footer>
</div>
<script defer src=https://platform.twitter.com/widgets.js></script>
<script defer src=https://platform.instagram.com/en_US/embeds.js></script>
<script defer src=https://strava-embeds.com/embed.js></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/highlight.min.js></script>
<script type=module>
import AffiliateLink from '/js/affiliate-link.js';

customElements.define('affiliate-link', AffiliateLink);

document.querySelectorAll('pre code').forEach(block => {
  hljs.highlightBlock(block);
});

document.querySelector('.Share__Item button').addEventListener('click', async event => {
  event.preventDefault();

  const data = {
    title: document.title,
    text: document.title,
    url: location.href
  };

  if (navigator.canShare?.(data)) {
    await navigator.share(data);
  } else {
    await navigator.clipboard?.writeText(`${data.title} ${data.url}`);
    const popover = document.querySelector('#Popover');
    popover.showPopover();

    setTimeout(() => {
      popover.hidePopover();
    }, 2000);
  }
});
</script>
</body>
</html>